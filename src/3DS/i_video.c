/* Emacs style mode select   -*- C++ -*-
 *-----------------------------------------------------------------------------
 *
 *
 *  PrBoom: a Doom port merged with LxDoom and LSDLDoom
 *  based on BOOM, a modified and improved DOOM engine
 *  Copyright (C) 1999 by
 *  id Software, Chi Hoang, Lee Killough, Jim Flynn, Rand Phares, Ty Halderman
 *  Copyright (C) 1999-2006 by
 *  Jess Haas, Nicolas Kalkhof, Colin Phipps, Florian Schulze
 *  Copyright 2005, 2006 by
 *  Florian Schulze, Colin Phipps, Neil Stevens, Andrey Budko
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 *  02111-1307, USA.
 *
 * DESCRIPTION:
 *  DOOM graphics stuff for SDL
 *
 *-----------------------------------------------------------------------------
 */

#include <strings.h>
#include <stdlib.h>
#include <assert.h>

#include <SDL/SDL.h>

#include "m_argv.h"
#include "doomstat.h"
#include "doomdef.h"
#include "doomtype.h"
#include "v_video.h"
#include "r_draw.h"
#include "r_things.h"
#include "r_plane.h"
#include "r_main.h"
#include "f_wipe.h"
#include "d_main.h"
#include "d_event.h"
#include "d_deh.h"
#include "i_joy.h"
#include "i_video.h"
#include "z_zone.h"
#include "s_sound.h"
#include "sounds.h"
#include "w_wad.h"
#include "st_stuff.h"
#include "am_map.h"
#include "g_game.h"
#include "lprintf.h"
#include "i_system.h"

#ifdef GL_DOOM
#include "gl_struct.h"
#endif

#include "e6y.h"//e6y
#include "i_main.h"

#include <3ds.h>
#include <citro3d.h>

#define DISPLAY_TRANSFER_FLAGS \
  (GX_TRANSFER_FLIP_VERT(0) | GX_TRANSFER_OUT_TILED(0) | GX_TRANSFER_RAW_COPY(0) | \
  GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGB8) | \
  GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

//e6y: new mouse code
//static SDL_Cursor* cursors[2] = {NULL, NULL};

static int mouse_currently_grabbed = true;

static void ActivateMouse(void);
static void DeactivateMouse(void);
//static int AccelerateMouse(int val);
static void I_ReadMouse(void);
static dboolean MouseShouldBeGrabbed();

extern void M_QuitDOOM(int choice);

int vanilla_keymap;
static void *screen = NULL;
C3D_RenderTarget *hw_screen = NULL;

////////////////////////////////////////////////////////////////////////////
// Input code
static int             leds_always_off = 0; // Expected by m_misc, not relevant

// Mouse handling
extern int     usemouse;        // config file var
static dboolean mouse_enabled; // usemouse, but can be overriden by -nomouse

video_mode_t I_GetModeFromString(const char *modestr);

/////////////////////////////////////////////////////////////////////////////////
// Keyboard handling

//
//  Translates the key currently in key
//
static int I_TranslateKey(SDL_keysym* key)
{
  int rc = 0;

  switch (key->sym) {
  case SDLK_LEFT: rc = KEYD_LEFTARROW;  break;
  case SDLK_RIGHT:  rc = KEYD_RIGHTARROW; break;
  case SDLK_DOWN: rc = KEYD_DOWNARROW;  break;
  case SDLK_UP:   rc = KEYD_UPARROW;  break;
  case SDLK_ESCAPE: rc = KEYD_ESCAPE; break;
  case SDLK_RETURN: rc = KEYD_ENTER;  break;
  case SDLK_TAB:  rc = KEYD_TAB;    break;
  case SDLK_F1:   rc = KEYD_F1;   break;
  case SDLK_F2:   rc = KEYD_F2;   break;
  case SDLK_F3:   rc = KEYD_F3;   break;
  case SDLK_F4:   rc = KEYD_F4;   break;
  case SDLK_F5:   rc = KEYD_F5;   break;
  case SDLK_F6:   rc = KEYD_F6;   break;
  case SDLK_F7:   rc = KEYD_F7;   break;
  case SDLK_F8:   rc = KEYD_F8;   break;
  case SDLK_F9:   rc = KEYD_F9;   break;
  case SDLK_F10:  rc = KEYD_F10;    break;
  case SDLK_F11:  rc = KEYD_F11;    break;
  case SDLK_F12:  rc = KEYD_F12;    break;
  case SDLK_BACKSPACE:  rc = KEYD_BACKSPACE;  break;
  case SDLK_DELETE: rc = KEYD_DEL;  break;
  case SDLK_INSERT: rc = KEYD_INSERT; break;
  case SDLK_PAGEUP: rc = KEYD_PAGEUP; break;
  case SDLK_PAGEDOWN: rc = KEYD_PAGEDOWN; break;
  case SDLK_HOME: rc = KEYD_HOME; break;
  case SDLK_END:  rc = KEYD_END;  break;
  case SDLK_PAUSE:  rc = KEYD_PAUSE;  break;
  case SDLK_EQUALS: rc = KEYD_EQUALS; break;
  case SDLK_MINUS:  rc = KEYD_MINUS;  break;
  case SDLK_KP0:  rc = KEYD_KEYPAD0;  break;
  case SDLK_KP1:  rc = KEYD_KEYPAD1;  break;
  case SDLK_KP2:  rc = KEYD_KEYPAD2;  break;
  case SDLK_KP3:  rc = KEYD_KEYPAD3;  break;
  case SDLK_KP4:  rc = KEYD_KEYPAD4;  break;
  case SDLK_KP5:  rc = KEYD_KEYPAD5;  break;
  case SDLK_KP6:  rc = KEYD_KEYPAD6;  break;
  case SDLK_KP7:  rc = KEYD_KEYPAD7;  break;
  case SDLK_KP8:  rc = KEYD_KEYPAD8;  break;
  case SDLK_KP9:  rc = KEYD_KEYPAD9;  break;
  case SDLK_KP_PLUS:  rc = KEYD_KEYPADPLUS; break;
  case SDLK_KP_MINUS: rc = KEYD_KEYPADMINUS;  break;
  case SDLK_KP_DIVIDE:  rc = KEYD_KEYPADDIVIDE; break;
  case SDLK_KP_MULTIPLY: rc = KEYD_KEYPADMULTIPLY; break;
  case SDLK_KP_ENTER: rc = KEYD_KEYPADENTER;  break;
  case SDLK_KP_PERIOD:  rc = KEYD_KEYPADPERIOD; break;
  case SDLK_LSHIFT:
  case SDLK_RSHIFT: rc = KEYD_RSHIFT; break;
  case SDLK_LCTRL:
  case SDLK_RCTRL:  rc = KEYD_RCTRL;  break;
  case SDLK_LALT:
  case SDLK_LSUPER:
  case SDLK_RALT:
  case SDLK_RSUPER:  rc = KEYD_RALT;   break;
  case SDLK_CAPSLOCK: rc = KEYD_CAPSLOCK; break;
  case SDLK_PRINT: rc = KEYD_PRINTSC; break;
  case SDLK_SCROLLOCK: rc = KEYD_SCROLLLOCK; break;
  default:    rc = key->sym;    break;
  }

  return rc;

}

/////////////////////////////////////////////////////////////////////////////////
// Main input code

/* cph - pulled out common button code logic */
//e6y static 
static int I_SDLtoDoomMouseState(Uint32 buttonstate)
{
  return 0
      | (buttonstate & SDL_BUTTON(1) ? 1 : 0)
      | (buttonstate & SDL_BUTTON(2) ? 2 : 0)
      | (buttonstate & SDL_BUTTON(3) ? 4 : 0)
      | (buttonstate & SDL_BUTTON(6) ? 8 : 0)
      | (buttonstate & SDL_BUTTON(7) ? 16 : 0)
      | (buttonstate & SDL_BUTTON(4) ? 32 : 0)
      | (buttonstate & SDL_BUTTON(5) ? 64 : 0)
      | (buttonstate & SDL_BUTTON(8) ? 128 : 0)
      ;
}

static void I_GetEvent(void)
{
  event_t event;

  SDL_Event SDLEvent;
  SDL_Event *Event = &SDLEvent;

  static int mwheeluptic = 0, mwheeldowntic = 0;

  /* while (SDL_PollEvent(Event))
  {
    switch (Event->type) {
    case SDL_KEYDOWN:
      if (Event->key.keysym.mod & KMOD_LALT)
      {
        // Prevent executing action on Alt-Tab
        if (Event->key.keysym.sym == SDLK_TAB)
        {
          break;
        }
        // Immediately exit on Alt+F4 ("Boss Key")
        else if (Event->key.keysym.sym == SDLK_F4)
        {
          I_SafeExit(0);
          break;
        }
      }
      event.type = ev_keydown;
      event.data1 = I_TranslateKey(&Event->key.keysym);
      D_PostEvent(&event);
      break;

    case SDL_KEYUP:
    {
      event.type = ev_keyup;
      event.data1 = I_TranslateKey(&Event->key.keysym);
      D_PostEvent(&event);
    }
    break;

    case SDL_MOUSEBUTTONDOWN:
    case SDL_MOUSEBUTTONUP:
    if (mouse_enabled)
    {
      if (Event->button.button == SDL_BUTTON_WHEELUP)
      {
        event.type = ev_keydown;
        event.data1 = KEYD_MWHEELUP;
        mwheeluptic = gametic;
        D_PostEvent(&event);
      }
      else if (Event->button.button == SDL_BUTTON_WHEELDOWN)
      {
        event.type = ev_keydown;
        event.data1 = KEYD_MWHEELDOWN;
        mwheeldowntic = gametic;
        D_PostEvent(&event);
      }
      else
      {
        event.type = ev_mouse;
        event.data1 = I_SDLtoDoomMouseState(SDL_GetMouseState(NULL, NULL));
        event.data2 = event.data3 = 0;
        D_PostEvent(&event);
      }
    }
    break;

    case SDL_QUIT:
      S_StartSound(NULL, sfx_swtchn);
      M_QuitDOOM(0);

    default:
      break;
    }
  } */

  if(mwheeluptic && mwheeluptic + 1 < gametic)
  {
    event.type = ev_keyup;
    event.data1 = KEYD_MWHEELUP;
    D_PostEvent(&event);
    mwheeluptic = 0;
  }

  if(mwheeldowntic && mwheeldowntic + 1 < gametic)
  {
    event.type = ev_keyup;
    event.data1 = KEYD_MWHEELDOWN;
    D_PostEvent(&event);
    mwheeldowntic = 0;
  }
}

//
// I_StartTic
//

void I_StartTic (void)
{
  I_GetEvent();

  I_ReadMouse();

  I_PollJoystick();
}

//
// I_StartFrame
//
void I_StartFrame (void)
{
}

//
// I_InitInputs
//

static void I_InitInputs(void)
{
  static Uint8 empty_cursor_data = 0;

  int nomouse_parm = M_CheckParm("-nomouse");

  // check if the user wants to use the mouse
  mouse_enabled = usemouse && !nomouse_parm;
  
  // SDL_PumpEvents();

  // Save the default cursor so it can be recalled later
  //cursors[0] = SDL_GetCursor();
  // Create an empty cursor
  //cursors[1] = SDL_CreateCursor(&empty_cursor_data, &empty_cursor_data, 8, 1, 0, 0);

  if (mouse_enabled)
  {
    MouseAccelChanging();
  }

  I_InitJoystick();
}
/////////////////////////////////////////////////////////////////////////////

// I_SkipFrame
//
// Returns true if it thinks we can afford to skip this frame

inline static dboolean I_SkipFrame(void)
{
  static int frameno;

  frameno++;
  switch (gamestate) {
  case GS_LEVEL:
    if (!paused)
      return false;
  default:
    // Skip odd frames
    return (frameno & 1) ? true : false;
  }
}

//////////////////////////////////////////////////////////////////////////////
// Graphics API

void I_SwapBuffers(void)
{
  // End frame
  C3D_FrameEnd(0);

  // Start next frame
  C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
  C3D_FrameDrawOn(hw_screen);
}

void I_ShutdownGraphics(void)
{
  // SDL_FreeCursor(cursors[1]);
  DeactivateMouse();
}

//
// I_UpdateNoBlit
//
void I_UpdateNoBlit (void)
{
}

static inline u16 argb1555_2_rgba5551(u16 x) {
  return (x << 1) | ((x & 0x8000) >> 15);
}

static inline u32 argb8_2_rgba8(u32 x) {
  return (x << 8) | ((x & 0xff000000) >> 24);
}

//
// I_FinishUpdate
//
void I_FinishUpdate (void)
{
  //e6y: new mouse code
  UpdateGrab();

  // The screen wipe following pressing the exit switch on a level
  // is noticably jerkier with I_SkipFrame
  // if (I_SkipFrame())return;

#ifdef GL_DOOM
  if (V_GetMode() == VID_MODEGL) {
    // proff 04/05/2000: swap OpenGL buffers
    gld_Finish();
    return;
  }
#endif

  switch(V_GetMode()) {
  case VID_MODE15:
  {
    u16* dst_ptr = (u16*)gfxGetFramebuffer(GFX_TOP, GFX_LEFT, NULL, NULL) + 239;
    u16* src_ptr = (u16*)screens[0].data;

    for(int y = 0; y < 240; y++) {
      for(int x = 0; x < 400; x++) {
        *dst_ptr = argb1555_2_rgba5551(*src_ptr);

        dst_ptr += 240;
        src_ptr++;
      }
      dst_ptr -= (400 * 240) + 1;
    }
    break;
  }
  case VID_MODE16:
  {
    u16* dst_ptr = (u16*)gfxGetFramebuffer(GFX_TOP, GFX_LEFT, NULL, NULL) + 239;
    u16* src_ptr = (u16*)screens[0].data;

    for(int y = 0; y < 240; y++) {
      for(int x = 0; x < 400; x++) {
        *dst_ptr = *src_ptr;

        dst_ptr += 240;
        src_ptr++;
      }
      dst_ptr -= (400 * 240) + 1;
    }
    break;
  }
  default: // VID_MODE32
  {
    u32* dst_ptr = (u32*)gfxGetFramebuffer(GFX_TOP, GFX_LEFT, NULL, NULL) + 239;
    u32* src_ptr = (u32*)screens[0].data;

    for(int y = 0; y < 240; y++) {
      for(int x = 0; x < 400; x++) {
        *dst_ptr = argb8_2_rgba8(*src_ptr);

        dst_ptr += 240;
        src_ptr++;
      }
      dst_ptr -= (400 * 240) + 1;
    }
    break;
  }
  }

  // Draw!

  // Flush and swap framebuffers
  gfxFlushBuffers();
  gfxSwapBuffers();

  gspWaitForVBlank();
}

static void I_ShutdownSDL(void)
{
}

void I_PreInitGraphics(void)
{
  I_AtExit(I_ShutdownSDL, true);
}

// e6y: resolution limitation is removed
static void I_InitBuffersRes(void)
{
  R_InitMeltRes();
  R_InitSpritesRes();
  R_InitBuffersRes();
  R_InitPlanesRes();
  R_InitVisplanesRes();
}

//
// I_GetScreenResolution
// Always set 400x240 for 3DS
//
static void I_GetScreenResolution(void)
{
  desired_screenwidth = 400;
  desired_screenheight = 240;
}

// e6y
// It is a simple test of CPU cache misses.
static unsigned int I_TestCPUCacheMisses(int width, int height, unsigned int mintime)
{
  int i, k;
  char *s, *d, *ps, *pd;
  unsigned int tickStart;
  
  s = (char*)malloc(width * height);
  d = (char*)malloc(width * height);

  tickStart = I_GetTime_MS();
  k = 0;
  do
  {
    ps = s;
    pd = d;
    for(i = 0; i < height; i++)
    {
      pd[0] = ps[0];
      pd += width;
      ps += width;
    }
    k++;
  }
  while (I_GetTime_MS() - tickStart < mintime);

  free(d);
  free(s);

  return k;
}

// CPhipps -
// I_CalculateRes
// Calculates the screen resolution, possibly using the supplied guide
static void I_CalculateRes(int width, int height)
{
// e6y
// GLBoom will try to set the closest supported resolution 
// if the requested mode can't be set correctly.
// For example glboom.exe -geom 1025x768 -nowindow will set 1024x768.
// It affects only fullscreen modes.
  if (V_GetMode() == VID_MODEGL) {
    SCREENWIDTH = width;
    SCREENHEIGHT = height;
    SCREENPITCH = SCREENWIDTH;
  }
  else {
    unsigned int count1, count2;
    int pitch1, pitch2;

    SCREENWIDTH = width; //(width+15) & ~15;
    SCREENHEIGHT = height;

    // e6y
    // Trying to optimise screen pitch for reducing of CPU cache misses.
    // It is extremally important for wiping in software.
    // I have ~20x improvement in speed with using 1056 instead of 1024 on Pentium4
    // and only ~10% for Core2Duo
    if (1)
    {
      unsigned int mintime = 100;
      int w = (width+15) & ~15;
      pitch1 = w * V_GetPixelDepth();
      pitch2 = w * V_GetPixelDepth() + 32;

      count1 = I_TestCPUCacheMisses(pitch1, SCREENHEIGHT, mintime);
      count2 = I_TestCPUCacheMisses(pitch2, SCREENHEIGHT, mintime);

      lprintf(LO_INFO, "I_CalculateRes: trying to optimize screen pitch\n");
      lprintf(LO_INFO, " test case for pitch=%d is processed %d times for %d msec\n", pitch1, count1, mintime);
      lprintf(LO_INFO, " test case for pitch=%d is processed %d times for %d msec\n", pitch2, count2, mintime);

      SCREENPITCH = (count2 > count1 ? pitch2 : pitch1);

      lprintf(LO_INFO, " optimized screen pitch is %d\n", SCREENPITCH);
    }
    else
    {
      SCREENPITCH = SCREENWIDTH * V_GetPixelDepth();
    }
  }
}

// CPhipps -
// I_InitScreenResolution
// Sets the screen resolution
void I_InitScreenResolution(void)
{
  int i, p, w, h;
  char c, x;
  video_mode_t mode;

  I_GetScreenResolution();

  if (!screen && !hw_screen)
  {
    // e6y
    // change the screen size for the current session only
    // syntax: -geom WidthxHeight[w|f]
    // examples: -geom 320x200f, -geom 640x480w, -geom 1024x768
    w = desired_screenwidth;
    h = desired_screenheight;

    if (!(p = M_CheckParm("-geom")))
      p = M_CheckParm("-geometry");

    if (p && p + 1 < myargc)
    {
      int count = sscanf(myargv[p+1], "%d%c%d%c", &w, &x, &h, &c);

      // at least width and height must be specified
      // restoring original values if not
      if (count < 3 || tolower(x) != 'x')
      {
        w = desired_screenwidth;
        h = desired_screenheight;
      }
    }
  }
  else
  {
    w = desired_screenwidth;
    h = desired_screenheight;
  }

  mode = (video_mode_t)I_GetModeFromString(default_videomode);
  if ((i=M_CheckParm("-vidmode")) && i<myargc-1)
  {
    mode = (video_mode_t)I_GetModeFromString(myargv[i+1]);
  }
#ifndef GL_DOOM
  if (mode == VID_MODEGL)
  {
    mode = (video_mode_t)I_GetModeFromString(default_videomode = "32bit");
  }
#endif
  
  V_InitMode(mode);

  I_CalculateRes(w, h);
  V_DestroyUnusedTrueColorPalettes();
  V_FreeScreens();

  // set first three to standard values
  for (i=0; i<3; i++) {
    screens[i].width = SCREENWIDTH;
    screens[i].height = SCREENHEIGHT;
    screens[i].byte_pitch = SCREENPITCH;
    screens[i].short_pitch = SCREENPITCH / V_GetModePixelDepth(VID_MODE16);
    screens[i].int_pitch = SCREENPITCH / V_GetModePixelDepth(VID_MODE32);
  }

  // statusbar
  screens[4].width = SCREENWIDTH;
  screens[4].height = SCREENHEIGHT;
  screens[4].byte_pitch = SCREENPITCH;
  screens[4].short_pitch = SCREENPITCH / V_GetModePixelDepth(VID_MODE16);
  screens[4].int_pitch = SCREENPITCH / V_GetModePixelDepth(VID_MODE32);

  I_InitBuffersRes();

  lprintf(LO_INFO,"I_InitScreenResolution: Using resolution %dx%d\n", SCREENWIDTH, SCREENHEIGHT);
}

void I_InitGraphics(void)
{
  static int    firsttime=1;

  if (firsttime)
  {
    firsttime = 0;

    I_AtExit(I_ShutdownGraphics, true);
    lprintf(LO_INFO, "I_InitGraphics: %dx%d\n", SCREENWIDTH, SCREENHEIGHT);

    /* Set the video mode */
    I_UpdateVideoMode();

    /* Initialize the input system */
    I_InitInputs();

    //e6y: new mouse code
    UpdateGrab();
  }
}

video_mode_t I_GetModeFromString(const char *modestr)
{
  video_mode_t mode;

  if (!strcasecmp(modestr,"15")) {
    mode = VID_MODE15;
  } else if (!strcasecmp(modestr,"15bit")) {
    mode = VID_MODE15;
  } else if (!strcasecmp(modestr,"16")) {
    mode = VID_MODE16;
  } else if (!strcasecmp(modestr,"16bit")) {
    mode = VID_MODE16;
  } else if (!strcasecmp(modestr,"gl")) {
    mode = VID_MODEGL;
  } else if (!strcasecmp(modestr,"OpenGL")) {
    mode = VID_MODEGL;
  } else {
    mode = VID_MODE32;
  }

  return mode;
}

void I_UpdateVideoMode(void)
{
  // Was HW renderer just used?
  if(hw_screen)
  {
    I_InitScreenResolution();

#ifdef GL_DOOM
    gld_CleanMemory();
    // hires patches
    gld_CleanStaticMemory();
#endif

    C3D_RenderTargetDelete(hw_screen);
    hw_screen = NULL;

    gl_wrapper_cleanup();

    C3D_Fini();
  }
  // Was SW renderer just used?
  else if(screen)
  {
    I_InitScreenResolution();

    free(screen);
    screen = NULL;

    gfxExit();
  }

  gfxInitDefault();

  if (V_GetMode() != VID_MODEGL)
  {
    GSPGPU_FramebufferFormat top_fmt;
    int screen_pitch;

    switch(V_GetNumPixelBits())
    {
      case 15:
        top_fmt = GSP_RGB5_A1_OES;
        screen_pitch = 400 * 2;
        break;
      case 16:
        top_fmt = GSP_RGB565_OES;
        screen_pitch = 400 * 2;
        break;
      default:
        top_fmt = GSP_RGBA8_OES;
        screen_pitch = 400 * 4;
        break;
    }

    gfxSetScreenFormat(GFX_TOP, top_fmt);

    screen = malloc(screen_pitch * 240);

    screens[0].not_on_heap = true;
    screens[0].data = (unsigned char *) (screen);
    screens[0].byte_pitch = screen_pitch;
    screens[0].short_pitch = screen_pitch / V_GetModePixelDepth(VID_MODE16);
    screens[0].int_pitch = screen_pitch / V_GetModePixelDepth(VID_MODE32);

    V_AllocScreens();

    R_InitBuffer(SCREENWIDTH, SCREENHEIGHT);
  }
  else
  {
    C3D_Init(C3D_DEFAULT_CMDBUF_SIZE);

    hw_screen = C3D_RenderTargetCreate(240, 400, GPU_RB_RGBA8, GPU_RB_DEPTH16);
    C3D_RenderTargetSetOutput(hw_screen, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

    gl_wrapper_init();

    // Start first frame
    C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
    C3D_FrameDrawOn(hw_screen);
  }

  // e6y: wide-res
  // Need some initialisations before level precache
  R_ExecuteSetViewSize();

  V_SetPalette(0);

  ST_SetResolution();
  AM_SetResolution();

#ifdef GL_DOOM
  if (V_GetMode() == VID_MODEGL)
  {
    gld_Init(SCREENWIDTH, SCREENHEIGHT);

    M_ChangeFOV();
    deh_changeCompTranslucency();
  }
#endif
}

static void ActivateMouse(void)
{
  //SDL_WM_GrabInput(SDL_GRAB_ON);
  //SDL_ShowCursor(SDL_DISABLE);
  //SDL_GetRelativeMouseState(NULL, NULL);
}

static void DeactivateMouse(void)
{
  //SDL_WM_GrabInput(SDL_GRAB_OFF);
  //SDL_ShowCursor(SDL_ENABLE);
}

//
// Read the change in mouse state to generate mouse motion events
//
// This is to combine all mouse movement for a tic into one mouse
// motion event.

static void SmoothMouse(int* x, int* y)
{
    static int x_remainder_old = 0;
    static int y_remainder_old = 0;

    int x_remainder, y_remainder;
    fixed_t correction_factor;

    const fixed_t fractic = I_TickElapsedTime();

    *x += x_remainder_old;
    *y += y_remainder_old;

    correction_factor = FixedDiv(fractic, FRACUNIT + fractic);

    x_remainder = FixedMul(*x, correction_factor);
    *x -= x_remainder;
    x_remainder_old = x_remainder;

    y_remainder = FixedMul(*y, correction_factor);
    *y -= y_remainder;
    y_remainder_old = y_remainder;
}

static void I_ReadMouse(void)
{
  if (mouse_enabled)
  {
    int x, y;

    //SDL_GetRelativeMouseState(&x, &y);
    SmoothMouse(&x, &y);

    if (x != 0 || y != 0)
    {
      event_t event;
      event.type = ev_mousemotion;
      event.data1 = 0;
      event.data2 = x << 4;
      event.data3 = -y << 4;

      D_PostEvent(&event);
    }
  }

  if (!usemouse)
    return;

  if (!MouseShouldBeGrabbed())
  {
    mouse_currently_grabbed = false;
    return;
  }

  if (!mouse_currently_grabbed)
  {
    mouse_currently_grabbed = true;
  }
}

static dboolean MouseShouldBeGrabbed()
{
  // if we specify not to grab the mouse, never grab
  if (!mouse_enabled)
    return false;

  // always grab the mouse in camera mode when playing levels 
  // and menu is not active
  if (walkcamera.type)
    return (demoplayback && gamestate == GS_LEVEL && !menuactive);

  // when menu is active or game is paused, release the mouse 
  if (menuactive || paused)
    return false;

  // only grab mouse when playing levels (but not demos)
  return (gamestate == GS_LEVEL) && !demoplayback;
}

void UpdateGrab(void)
{
  static dboolean currently_grabbed = false;
  dboolean grab;

  grab = MouseShouldBeGrabbed();

  if (grab && !currently_grabbed)
  {
    ActivateMouse();
  }

  if (!grab && currently_grabbed)
  {
    DeactivateMouse();
  }

  currently_grabbed = grab;
}
